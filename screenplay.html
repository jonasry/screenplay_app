<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Screenplay Page Writer — Fountain Import/Export</title>
  <style>
    :root{ --page-bg:#fafafa; --ink:#111; --accent:#2d6cdf; --toolbar-bg:#fff; --toolbar-border:#ddd }
    html,body{height:100%;margin:0;background:var(--page-bg);color:var(--ink);font-family:"Courier New", Courier, monospace;font-size:12pt}
    .toolbar{position:sticky;top:0;z-index:10;display:flex;flex-wrap:wrap;gap:.5em;padding:.5em;background:var(--toolbar-bg);border-bottom:1px solid var(--toolbar-border);box-shadow:0 1px 4px rgba(0,0,0,.05)}
    .toolbar button{font-family:inherit;font-size:11pt;padding:.4em .6em;border:1px solid var(--toolbar-border);background:#fff;cursor:pointer;border-radius:6px}
    .toolbar .right{margin-left:auto;display:flex;gap:.5em;flex-wrap:wrap;align-items:center}
    .toolbar button.active{outline:2px solid var(--accent)}

    /* File hamburger menu */
    .menu{position:relative}
    .menu-trigger{display:flex;align-items:center;gap:.4em}
    .menu-panel{position:absolute;right:0;top:calc(100% + .25em);min-width:14rem;background:#fff;border:1px solid var(--toolbar-border);border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.12);padding:.4em;display:flex;flex-direction:column;z-index:11}
    .menu-panel[hidden]{display:none !important}
    .menu-panel button{display:block;width:100%;text-align:left;margin:0;padding:.5em .7em;border:0;background:transparent;border-radius:6px}
    .menu-panel button:hover,.menu-panel button:focus{background:#f2f2f2;outline:none}
    .menu-sep{border:0;border-top:1px solid #e6e6e6;margin:.3em .2em}
    .doc-title{color:#444;padding:.2em .5em;border:1px dashed transparent;border-radius:6px;max-width:28ch;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}

    /* Simple modal for Load dialog */
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:50}
    .modal{background:#fff;color:var(--ink);min-width:22em;max-width:90vw;max-height:80vh;border:1px solid var(--toolbar-border);border-radius:10px;box-shadow:0 12px 32px rgba(0,0,0,.25);padding:1em;display:flex;flex-direction:column;gap:.8em}
    .modal h3{margin:0 0 .2em 0;font-size:1.1em}
    .doc-list{display:flex;flex-direction:column;gap:.3em;overflow:auto}
    .doc-item{display:flex;align-items:center;justify-content:space-between;gap:.8em;border:1px solid #eee;border-radius:8px;padding:.5em .7em}
    .doc-item button{border:1px solid var(--toolbar-border);padding:.3em .6em;border-radius:6px;background:#fff;cursor:pointer}
    .doc-meta{display:flex;flex-direction:column}
    .doc-name{font-weight:600}
    .doc-updated{font-size:.85em;color:#666}

    .page{box-sizing:border-box;width:8.5in;min-height:11in;margin:1em auto 2em;background:#fff;color:var(--ink);padding:1in 1in 1in 1.5in;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .block{outline:none;white-space:pre-wrap}
    .block+.block{margin-top:.5em}
    .slug{text-transform:uppercase}
    .action{text-align:left}
    .dialogue{width:4.25in;margin:0 auto;text-align:left}
    .character{width:2.5in;margin:0 auto .2em;text-align:center;text-transform:uppercase}
    .paren{width:3.5in;margin:0 auto;text-align:left}
    .transition{text-align:right;letter-spacing:0.04em;text-transform:uppercase}

    /* Spacing adjustments for screenplay rhythm */
    .block + .slug{margin-top:1.2em}               /* extra space before new scene */
    .block + .character{margin-top:1.2em}          /* visual blank line before character */
    .block + .transition{margin-top:1.2em}         /* extra space before transitions */
    .slug + .action{margin-top:1.0em}              /* extra space after slug before first action */
    .character + .dialogue{margin-top:.2em}        /* tighten dialogue after character */
    .character + .paren{margin-top:.2em}           /* tight parenthetical after character */
    .paren + .dialogue{margin-top:.2em}            /* tight dialogue after parenthetical */
    .paren + .action{margin-top:1.2em}             /* extra space when action follows parenthetical */
    .dialogue + .paren {margin-top:.2em}           /* tight dialogue after parenthetical */
    .dialogue + .action{margin-top:1.2em}          /* extra space when action follows dialogue */

    .block[data-empty="true"]::before{content:attr(data-placeholder);color:#888;pointer-events:none}

    @media print{body{background:#fff}.toolbar{display:none}.page{box-shadow:none;margin:0;width:auto;min-height:auto}@page{margin:0}}
  </style>
</head>
<body>
  <div class="toolbar" role="toolbar" aria-label="Screenplay controls">
    <button data-insert="slug" title="Scene Heading (Ctrl/⌘+1)">Scene Heading</button>
    <button data-insert="action" title="Action (Ctrl/⌘+2)">Action</button>
    <button data-insert="character" title="Character (Ctrl/⌘+3)">Character</button>
    <button data-insert="dialogue" title="Dialogue (Ctrl/⌘+4)">Dialogue</button>
    <button data-insert="paren" title="Parenthetical (Ctrl/⌘+5)">Parenthetical</button>
    <button data-insert="transition" title="Transition (Ctrl/⌘+6)">Transition</button>
    <div class="right">
      <div class="menu">
        <button id="btn-menu" class="menu-trigger" aria-haspopup="true" aria-expanded="false" aria-controls="file-menu" title="File menu">☰ File</button>
        <div id="file-menu" class="menu-panel" role="menu" aria-labelledby="btn-menu" hidden>
          <button id="btn-import" role="menuitem">Import .fountain</button>
          <button id="btn-export" role="menuitem">Export .fountain</button>
          <button id="btn-preview" role="menuitem">Preview .fountain</button>
          <button id="btn-copy" role="menuitem">Copy .fountain</button>
          <hr class="menu-sep" />
          <button id="btn-new" role="menuitem" title="New Document">New</button>
          <button id="btn-save" role="menuitem" title="Save to browser storage">Save</button>
          <button id="btn-saveas" role="menuitem">Save As…</button>
          <button id="btn-load" role="menuitem">Load…</button>
          <hr class="menu-sep" />
          <button id="btn-print" role="menuitem" title="Print / Export to PDF">Print / PDF</button>
        </div>
      </div>
      <div id="doc-title" class="doc-title" title="Current document name">Untitled</div>
    </div>
    <input type="file" id="file-fountain" accept=".fountain,.txt" hidden />
  </div>

  <main class="page" id="page" aria-label="Screenplay page" tabindex="-1"></main>

  <script>
  (function(){
    const page=document.getElementById('page');
    const LEGACY_SINGLE_KEY='screenplay-doc-v6';
    const STORAGE_INDEX_KEY='screenplay-index-v1';
    const STORAGE_CURRENT_KEY='screenplay-current-key';
    const DOC_PREFIX='screenplay-doc-';

    const PLACEHOLDERS={ slug:'INT./EXT. LOCATION - DAY/NIGHT', action:'Action: Describe what we see on screen in present tense.', character:'CHARACTER NAME', dialogue:'Dialogue goes here...', paren:'(whispering)', transition:'CUT TO:' };

    // Predictable flows
    const INSERT_FLOW_NEXT = { // when current line has text: insert a new block of this next type
      slug: 'action',
      action: 'character',
      character: 'dialogue',
      dialogue: 'character',
      paren: 'dialogue',
      transition: 'slug'
    };
    const INSERT_FLOW_PREV = { // shift+tab reverse for insert flow
      action: 'slug',
      character: 'action',
      dialogue: 'character',
      paren: 'character', // rarely used
      slug: 'transition',
      transition: 'dialogue' // arbitrary but helpful
    };

    const CYCLE_FLOW_NEXT = { // when current line is empty: change type in place
      slug: 'action',
      action: 'character',
      character: 'dialogue',
      dialogue: 'paren',
      paren: 'dialogue', // toggle
      transition: 'slug'
    };
    const CYCLE_FLOW_PREV = { // backwards cycling on Shift+Tab
      action: 'slug',
      character: 'action',
      dialogue: 'character',
      paren: 'dialogue',
      slug: 'transition',
      transition: 'slug'
    };

    function nextTypeForInsert(type, backwards){
      return backwards ? (INSERT_FLOW_PREV[type]||'action') : (INSERT_FLOW_NEXT[type]||'action');
    }
    function nextTypeForCycle(type, backwards){
      return backwards ? (CYCLE_FLOW_PREV[type]||'slug') : (CYCLE_FLOW_NEXT[type]||'action');
    }

    function createBlock(type,text=''){
      const el=document.createElement('div');
      el.className=`block ${type}`; el.contentEditable='true'; el.dataset.type=type; el.dataset.placeholder=PLACEHOLDERS[type]||''; if(!text) el.dataset.empty='true';
      el.textContent=text; el.addEventListener('input',handleInput); el.addEventListener('keydown',handleKeyDown); return el;
    }
    function insertBlock(type,text){
      const block=createBlock(type,text);
      const sel=getSelection();
      const anchor=sel && sel.anchorNode ? findBlock(sel.anchorNode):null;
      if(anchor && anchor.parentElement===page){ anchor.insertAdjacentElement('afterend',block);} else { page.appendChild(block);} placeCaretAtEnd(block); return block;
    }
    function changeBlockType(block, newType, opts={clear:false}){
      if(!block) { insertBlock(newType); return; }
      const prevText = opts.clear ? '' : (block.textContent||'');
      block.className = `block ${newType}`;
      block.dataset.type = newType;
      block.dataset.placeholder = PLACEHOLDERS[newType] || '';
      block.textContent = prevText;
      block.dataset.empty = block.textContent.trim()? 'false':'true';
      if(newType==='slug' || newType==='character'){
        block.textContent = block.textContent.toUpperCase();
      }
      placeCaretAtEnd(block);
      autoSaveDebounced();
      setActiveButton(newType);
    }

    function findBlock(node){ while(node && node!==page && !(node.classList && node.classList.contains('block'))){ node=node.parentNode;} return (node && node.classList && node.classList.contains('block'))?node:null; }
    function getActiveBlock(){ const sel=getSelection(); return sel && sel.anchorNode ? findBlock(sel.anchorNode) : null; }
    function placeCaretAtEnd(el){ el.focus(); const r=document.createRange(); r.selectNodeContents(el); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); }

    function getCaretCharacterOffsetWithin(element){ let caretOffset=0; const sel=window.getSelection(); if(!sel||sel.rangeCount===0) return 0; const range=sel.getRangeAt(0); const pre=range.cloneRange(); pre.selectNodeContents(element); pre.setEnd(range.endContainer, range.endOffset); caretOffset=pre.toString().length; return caretOffset; }
    function setCaretCharacterOffsetWithin(element, offset){ const range=document.createRange(); range.selectNodeContents(element); range.collapse(true); const stack=[element]; let charCount=0,node,found=false; while(!found && (node=stack.pop())){ if(node.nodeType===3){ const next=charCount+node.length; if(offset>=charCount && offset<=next){ range.setStart(node, offset-charCount); range.setEnd(node, offset-charCount); found=true;} charCount=next; } else { let i=node.childNodes.length; while(i--) stack.push(node.childNodes[i]); } } const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }

    function handleInput(e){ const el=e.currentTarget; el.dataset.empty=el.textContent.trim()?'false':'true'; if(['slug','character','transition'].includes(el.dataset.type)){ const start=getCaretCharacterOffsetWithin(el); el.textContent=el.textContent.toUpperCase(); setCaretCharacterOffsetWithin(el,start);} autoSaveDebounced(); }

    function handleKeyDown(e){
      const el=e.currentTarget; const type=el.dataset.type; const hasText=!!el.textContent.trim();
      // Enter inserts a logical next block
      if(e.key==='Enter'){
        e.preventDefault();
        const next = nextTypeForInsert(type, false);
        return insertBlock(next);
      }
      // Shift+Enter = soft line break
      if(e.key==='Enter' && e.shiftKey){ document.execCommand('insertLineBreak'); return; }
      // Tab: if line has text -> insert next type; if empty -> cycle current type
      if(e.key==='Tab'){
        e.preventDefault();
        const backwards = e.shiftKey;
        if(hasText){
          const next=nextTypeForInsert(type, backwards);
          insertBlock(next);
        } else {
          const next=nextTypeForCycle(type, backwards);
          changeBlockType(el, next);
        }
      }
      // Backspace on empty block removes it
      if(e.key==='Backspace' && !hasText){ e.preventDefault(); const prev=el.previousElementSibling; const parent=el.parentElement; el.remove(); if(prev) placeCaretAtEnd(prev); else parent && parent.focus(); }
    }

    function setActiveButton(type){ document.querySelectorAll('.toolbar button[data-insert]').forEach(btn=>btn.classList.toggle('active', btn.dataset.insert===type)); }

    // Toolbar buttons: convert current block if focused; otherwise insert new
    document.querySelectorAll('.toolbar button[data-insert]').forEach(btn=>btn.addEventListener('click', ()=>{
      const t=btn.dataset.insert; const current=getActiveBlock();
      if(current){ changeBlockType(current, t); }
      else { insertBlock(t); }
    }));

    // Shortcuts convert current when possible
    document.addEventListener('keydown',(e)=>{ const mod=e.ctrlKey||e.metaKey; if(mod){ const map={'1':'slug','2':'action','3':'character','4':'dialogue','5':'paren','6':'transition'}; const t=map[e.key]; if(t){ e.preventDefault(); const current=getActiveBlock(); if(current) changeBlockType(current, t); else insertBlock(t); } }});

    // ----- Multi-document storage -----
    function getIndex(){ try{ return JSON.parse(localStorage.getItem(STORAGE_INDEX_KEY)||'[]'); }catch{return []} }
    function setIndex(list){ localStorage.setItem(STORAGE_INDEX_KEY, JSON.stringify(list)); }
    function slugifyName(name){ return (name||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').replace(/-+/g,'-') || 'untitled'; }
    function generateKey(name){ const base=slugifyName(name||'untitled'); const suf=Math.floor(Date.now()/1000); return `${base}-${suf}`; }
    function docStorageKey(key){ return DOC_PREFIX+key; }
    function readDoc(key){ try{ const raw=localStorage.getItem(docStorageKey(key)); return raw? JSON.parse(raw):null; } catch{return null} }
    function writeDoc(doc){ if(!doc || !doc.key) return; const now=Date.now(); doc.updated=now; localStorage.setItem(docStorageKey(doc.key), JSON.stringify(doc)); const idx=getIndex(); const i=idx.findIndex(x=>x.key===doc.key); const meta={key:doc.key,name:doc.name||'Untitled',updated:doc.updated}; if(i>=0) idx[i]=meta; else idx.push(meta); setIndex(idx); localStorage.setItem(STORAGE_CURRENT_KEY, doc.key); }
    function getCurrentKey(){ return localStorage.getItem(STORAGE_CURRENT_KEY)||''; }
    function setCurrentKey(key){ if(key) localStorage.setItem(STORAGE_CURRENT_KEY,key); }

    function toJSONDoc(name, key){ const blocks=[...page.querySelectorAll('.block')].map(b=>({type:b.dataset.type,text:b.textContent})); return {v:7,name:name||'Untitled',key,updated:Date.now(),blocks}; }
    function fromJSONDoc(doc){ page.innerHTML=''; (doc.blocks||[]).forEach(b=>page.appendChild(createBlock(b.type,b.text||''))); if(!page.firstChild) page.appendChild(createBlock('slug','')); placeCaretAtEnd(page.lastChild); currentName=doc.name||'Untitled'; currentKey=doc.key||''; updateDocTitle(); }

    let currentName='Untitled';
    let currentKey='';
    function updateDocTitle(){ const t=document.getElementById('doc-title'); if(t) t.textContent=currentName||'Untitled'; }
    function save(){ if(!currentKey){ currentKey=generateKey(currentName); } const doc=toJSONDoc(currentName,currentKey); writeDoc(doc); updateDocTitle(); flash('Saved'); }
    async function saveAs(){ const name=prompt('Save As — enter document name:', currentName||'Untitled'); if(!name) return; currentName=name.trim()||'Untitled'; let key=generateKey(currentName); const idx=getIndex(); if(idx.some(d=>d.key===key)) key=`${key}-${Math.floor(Math.random()*1000)}`; currentKey=key; save(); }
    function newDoc(){ currentName='Untitled'; currentKey=generateKey(currentName); page.innerHTML=''; page.appendChild(createBlock('slug','')); placeCaretAtEnd(page.lastChild); save(); }
    function loadDocByKey(key){ const d=readDoc(key); if(!d){ flash('Document not found'); return; } fromJSONDoc(d); setCurrentKey(key); flash(`Loaded: ${d.name}`); }

    let saveTimer=null; function autoSaveDebounced(){ clearTimeout(saveTimer); saveTimer=setTimeout(save,600); }

    document.getElementById('btn-save' ).addEventListener('click',save);
    document.getElementById('btn-saveas').addEventListener('click',saveAs);
    document.getElementById('btn-load' ).addEventListener('click', showLoadDialog);
    document.getElementById('btn-new'  ).addEventListener('click',()=>{ if(confirm('Start a new document? Unsaved changes will be lost.')){ newDoc(); } });
    document.getElementById('btn-print').addEventListener('click',()=>window.print());

    // Hamburger menu toggle + a11y
    const menuTrigger = document.getElementById('btn-menu');
    const menuPanel = document.getElementById('file-menu');
    const menuItems = () => [...menuPanel.querySelectorAll('button[role="menuitem"]')];
    function openMenu(){ if(!menuPanel || !menuTrigger) return; menuPanel.hidden=false; menuTrigger.setAttribute('aria-expanded','true'); setTimeout(()=>{ const first=menuItems()[0]; first && first.focus(); },0); }
    function closeMenu(){ if(!menuPanel || !menuTrigger) return; menuPanel.hidden=true; menuTrigger.setAttribute('aria-expanded','false'); }
    function toggleMenu(){ if(menuPanel.hidden) openMenu(); else { closeMenu(); menuTrigger.focus(); } }
    if(menuTrigger){
      menuTrigger.addEventListener('click', (e)=>{ e.stopPropagation(); toggleMenu(); });
      menuTrigger.addEventListener('keydown', (e)=>{ if((e.key==='ArrowDown'||e.key==='Enter'||e.key===' ') && menuPanel){ e.preventDefault(); openMenu(); } });
    }
    if(menuPanel){
      // Basic arrow key navigation within menu
      menuPanel.addEventListener('keydown', (e)=>{
        const items=menuItems(); if(!items.length) return;
        const idx = items.indexOf(document.activeElement);
        if(e.key==='Escape'){ e.preventDefault(); closeMenu(); menuTrigger.focus(); return; }
        if(e.key==='ArrowDown'){ e.preventDefault(); const n = items[(idx+1)%items.length]; n && n.focus(); }
        if(e.key==='ArrowUp'){ e.preventDefault(); const p = items[(idx-1+items.length)%items.length]; p && p.focus(); }
        if(e.key==='Home'){ e.preventDefault(); items[0].focus(); }
        if(e.key==='End'){ e.preventDefault(); items[items.length-1].focus(); }
      });
      // Close when clicking outside or selecting an item
      document.addEventListener('click', (e)=>{ if(menuPanel.hidden) return; if(!menuPanel.contains(e.target) && e.target!==menuTrigger){ closeMenu(); } });
      menuPanel.addEventListener('click', (e)=>{ const target=e.target.closest('button'); if(target){ setTimeout(()=> closeMenu(), 0); }});
      window.addEventListener('blur', closeMenu);
      window.addEventListener('resize', closeMenu);
      window.addEventListener('scroll', closeMenu, true);
    }

    // ----- Fountain Import/Export -----
    const inputFile=document.getElementById('file-fountain');
    document.getElementById('btn-import').addEventListener('click',()=> inputFile.click());
    inputFile.addEventListener('change', async (e)=>{ const file=e.target.files[0]; if(!file) return; try{ const text=await file.text(); importFountain(text); }catch(err){ console.error(err); flash('Import failed'); } finally { inputFile.value=''; } });

    // Export to filesystem (suggested name from current doc)
    document.getElementById('btn-export').addEventListener('click', async()=>{
      const txt=exportFountain();
      if(!txt.trim()){ flash('Nothing to export'); return; }
      const suggested = (slugifyName(currentName)||'screenplay') + '.fountain';
      if('showSaveFilePicker' in window){
        try{
          const handle = await window.showSaveFilePicker({
            suggestedName: suggested,
            types: [{ description: 'Fountain', accept: { 'text/plain': ['.fountain', '.txt'] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(new Blob([txt], { type: 'text/plain;charset=utf-8' }));
          await writable.close();
          flash('Exported to file');
        } catch(err){ if(err && err.name !== 'AbortError') { console.error(err); flash('Export failed'); } }
      } else {
        safeDownload(suggested, txt);
        flash('Exported — check your downloads');
      }
    });

    // Preview .fountain in a new tab
    document.getElementById('btn-preview').addEventListener('click',()=>{
      const txt=exportFountain();
      if(!txt.trim()){ flash('Nothing to open'); return; }
      const w=window.open('', '_blank');
      if(!w){ flash('Popup blocked. Allow popups to preview.'); return; }
      const doc = w.document;
      doc.open();
      const title = (currentName||'Fountain Preview').replace(/[<>&]/g,'');
      doc.write('<!DOCTYPE html><html><head><meta charset="utf-8"><title>'+title+'</title><style>body{margin:0;padding:1rem;background:#fff;color:#111;font-family:\"Courier New\", Courier, monospace;font-size:12pt} pre{white-space:pre-wrap;word-wrap:break-word;margin:0}</style></head><body><pre></pre></body></html>');
      doc.close();
      const pre = doc.querySelector('pre');
      if(pre){ pre.textContent = txt; }
    });

    document.getElementById('btn-copy').addEventListener('click', async()=>{
      const txt=exportFountain();
      try{ await navigator.clipboard.writeText(txt); flash('Fountain copied'); }
      catch{ const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); flash('Fountain copied'); }
    });

    function safeDownload(filename, text){
      const blob=new Blob([text],{type:'application/octet-stream'});
      const url=(window.URL||window.webkitURL).createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url; a.download=filename; a.rel='noopener';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> (window.URL||window.webkitURL).revokeObjectURL(url), 2000);
    }

    function importFountain(src){
      const lines=src.replace(/\r\n?/g,'\n').split('\n');
      const blocks=[]; let i=0;
      const isSlug=(s)=>/^(?:\s*)(INT\.|EXT\.|INT\/EXT\.|EST\.)/.test(s.trim());
      const isTransition=(s)=>/^(?:CUT TO:|SMASH TO:|MATCH CUT TO:|FADE TO BLACK\.|FADE OUT:|FADE OUT\.|FADE IN:|DISSOLVE TO:|\w+ TO:)\s*$/i.test(s.trim());
      const isCharacter=(s)=>{ const t=s.trim(); if(!t) return false; if(/[a-z]/.test(t)) return false; if(/^(INT\.|EXT\.|EST\.)/.test(t)) return false; if(isTransition(t)) return false; return t.length>0 && t.length<40; };
      const isParen=(s)=>/^\s*\(.+\)\s*$/.test(s);

      while(i<lines.length){
        let line=lines[i];
        if(!blocks.length && !isSlug(line) && !isCharacter(line) && !line.trim()){ i++; continue; }
        if(isSlug(line)){ blocks.push({type:'slug',text:line.trim().toUpperCase()}); i++; continue; }
        if(isTransition(line)){
          blocks.push({type:'transition',text:line.trim().toUpperCase()}); i++;
          continue; }
        if(isCharacter(line)){
          blocks.push({type:'character',text:line.trim().toUpperCase()}); i++;
          if(i<lines.length && isParen(lines[i])){ blocks.push({type:'paren',text:lines[i].trim()}); i++; }
          let dialogueBuf=[];
          while(i<lines.length){
            const l=lines[i];
            if(!l.trim()){ i++; break; }
            if(isSlug(l)||isTransition(l)||isCharacter(l)) break;
            if(isParen(l)){
              if(dialogueBuf.length){ blocks.push({type:'dialogue',text:dialogueBuf.join('\n')}); dialogueBuf=[]; }
              blocks.push({type:'paren',text:l.trim()}); i++; continue;
            }
            dialogueBuf.push(l.replace(/^\s{0,10}/,'')); i++;
          }
          if(dialogueBuf.length){ blocks.push({type:'dialogue',text:dialogueBuf.join('\n')}); }
          continue;
        }
        if(line.trim()){
          const actionBuf=[line]; i++;
          while(i<lines.length){ const l=lines[i]; if(!l.trim()){ i++; break;} if(isSlug(l)||isTransition(l)||isCharacter(l)) break; actionBuf.push(l); i++; }
          blocks.push({type:'action',text:actionBuf.join('\n')}); continue;
        }
        i++;
      }

      page.innerHTML=''; if(blocks.length===0){ blocks.push({type:'slug',text:''}); }
      blocks.forEach(b=>page.appendChild(createBlock(b.type,b.text)));
      placeCaretAtEnd(page.lastChild); flash('Imported Fountain'); save();
    }

    function exportFountain(){
      const b=[...page.querySelectorAll('.block')]; const L=[];
      for(let i=0;i<b.length;i++){
        const type=b[i].dataset.type; const text=(b[i].textContent||'').replace(/\s+$/,'');
        const nextType = (b[i+1] && b[i+1].dataset.type) || '';
        if(!text){ if(type==='action' || type==='dialogue'){ L.push(''); } continue; }
        switch(type){
          case 'slug':
            L.push(text.toUpperCase());
            L.push('');
            break;
          case 'action':
            L.push(text);
            L.push('');
            break;
          case 'character':
            L.push(text.toUpperCase());
            break;
          case 'paren':
            L.push(text.trim());
            // If a parenthetical ends the speech (next isn't dialogue/paren), close with a blank line
            if(nextType !== 'dialogue' && nextType !== 'paren') L.push('');
            break;
          case 'dialogue':
            L.push(text);
            // Avoid inserting a blank line before a following parenthetical
            if(nextType !== 'paren') L.push('');
            break;
          case 'transition':
            L.push(text.toUpperCase());
            L.push('');
            break;
          default:
            L.push(text);
            L.push('');
        }
      }
      return L.join('\n').replace(/\n{3,}/g,'\n\n');
    }

    function flash(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',bottom:'1em',left:'50%',transform:'translateX(-50%)',background:'rgba(0,0,0,.85)',color:'#fff',padding:'.4em .7em',borderRadius:'6px',fontSize:'11pt',zIndex:99}); document.body.appendChild(t); setTimeout(()=>t.remove(),1600); }

    function fmtDate(ts){ try{ const d=new Date(ts); return d.toLocaleString(); }catch{return ''} }
    function showLoadDialog(){
      const idx = getIndex().sort((a,b)=> (b.updated||0)-(a.updated||0));
      if(!idx.length){ flash('No saved documents'); return; }
      const backdrop=document.createElement('div'); backdrop.className='modal-backdrop'; backdrop.tabIndex=-1;
      const modal=document.createElement('div'); modal.className='modal'; modal.role='dialog'; modal.ariaLabel='Load Document';
      modal.innerHTML='<h3>Load Document</h3><div class="doc-list"></div>';
      const list=modal.querySelector('.doc-list');
      idx.forEach(m=>{
        const item=document.createElement('div'); item.className='doc-item';
        const meta=document.createElement('div'); meta.className='doc-meta';
        const name=document.createElement('div'); name.className='doc-name'; name.textContent=m.name||m.key;
        const upd=document.createElement('div'); upd.className='doc-updated'; upd.textContent=fmtDate(m.updated);
        meta.appendChild(name); meta.appendChild(upd);
        const btn=document.createElement('button'); btn.textContent='Load'; btn.addEventListener('click',()=>{ loadDocByKey(m.key); close(); });
        item.appendChild(meta); item.appendChild(btn); list.appendChild(item);
      });
      function close(){ backdrop.remove(); }
      backdrop.addEventListener('click',(e)=>{ if(e.target===backdrop) close(); });
      backdrop.addEventListener('keydown',(e)=>{ if(e.key==='Escape') close(); });
      backdrop.appendChild(modal); document.body.appendChild(backdrop); modal.focus();
    }

    // init multi-document
    (function init(){
      const cur = getCurrentKey();
      if(cur){ const d=readDoc(cur); if(d){ fromJSONDoc(d); return; } }
      const idx = getIndex();
      if(idx.length){ const latest=idx.slice().sort((a,b)=> (b.updated||0)-(a.updated||0))[0]; const d=readDoc(latest.key); if(d){ fromJSONDoc(d); setCurrentKey(latest.key); return; } }
      // migrate legacy single doc once
      const legacy = localStorage.getItem(LEGACY_SINGLE_KEY);
      if(legacy){
        try{
          const obj = JSON.parse(legacy);
          const name='Imported';
          const key=generateKey(name);
          const doc={v:7,name,key,updated:Date.now(),blocks:(obj.blocks||[])};
          writeDoc(doc);
          fromJSONDoc(doc);
          return;
        }catch{}
      }
      // start fresh
      newDoc();
    })();

    page.addEventListener('focusin', (e)=>{ const b=findBlock(e.target); if(b) b.dataset.empty=b.textContent.trim()?'false':'true'; });
    page.addEventListener('focusout', (e)=>{ const b=findBlock(e.target); if(b) b.dataset.empty=b.textContent.trim()?'false':'true'; });
  })();
  </script>
</body>
</html>
